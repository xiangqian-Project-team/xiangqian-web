{"version":3,"file":"static/chunks/723-753745824918ac29.js","mappings":"yJAEAA,EADyB,CAAE,KAAQ,CAAE,IAAO,MAAO,MAAS,CAAE,QAAW,gBAAiB,UAAa,OAAQ,EAAG,SAAY,CAAC,CAAE,IAAO,OAAQ,MAAS,CAAE,EAAK,kOAAmO,CAAE,EAAE,EAAI,KAAQ,cAAe,MAAS,UAAW,WCetbC,EAA4BC,EAAAA,UAAgB,CATnB,SAA4BC,CAAK,CAAEC,CAAG,EAC7D,OAAoBF,EAAAA,aAAmB,CAACG,EAAAA,CAAQA,CAAEC,CAAAA,EAAAA,EAAAA,CAAAA,EAAS,CAAC,EAAGH,EAAO,CACpEC,IAAKA,EACLG,KAAMC,CACR,GACF,iFCVAC,EADsB,CAAE,KAAQ,CAAE,IAAO,MAAO,MAAS,CAAE,QAAW,gBAAiB,UAAa,OAAQ,EAAG,SAAY,CAAC,CAAE,IAAO,OAAQ,MAAS,CAAE,EAAK,ixDAAkxD,CAAE,EAAE,EAAI,KAAQ,UAAW,MAAS,UAAW,WCe99DC,EAA4BR,EAAAA,UAAgB,CATtB,SAAyBC,CAAK,CAAEC,CAAG,EACvD,OAAoBF,EAAAA,aAAmB,CAACG,EAAAA,CAAQA,CAAEC,CAAAA,EAAAA,EAAAA,CAAAA,EAAS,CAAC,EAAGH,EAAO,CACpEC,IAAKA,EACLG,KAAMI,CACR,GACF,kFCRA,IAAMC,EAAeC,CAAAA,EAAAA,EAAAA,aAAAA,EAAc,KAAK,GAClCC,EAAW,IACf,IAAMC,EAAQC,CAAAA,EAAAA,EAAAA,UAAAA,EAAWJ,GACzB,MAAO,CAACK,MAAAA,EAAkB,KAAK,EAAIA,EAAQF,KAAK,GAAKA,GAASG,CAAAA,EAAAA,EAAAA,EAAAA,GAChE,EAkBMC,EAAgB,GAAO,kBAAQC,CAAAA,MAAAA,EAAY,KAAK,EAAIA,EAAEC,IAAI,EAC1DC,EAAMC,EAAAA,GAAgB,EAAK,KAC/B,GAAIC,YAAAA,EAAQC,MAAM,CAChB,MAAMD,EACD,GAAIA,cAAAA,EAAQC,MAAM,CACvB,OAAOD,EAAQE,KAAK,CACf,GAAIF,aAAAA,EAAQC,MAAM,CACvB,MAAMD,EAAQG,MAAM,OAEpBH,EAAQC,MAAM,CAAG,UACjBD,EAAQH,IAAI,CACV,IACEG,EAAQC,MAAM,CAAG,YACjBD,EAAQE,KAAK,CAAGE,CAClB,EACA,IACEJ,EAAQC,MAAM,CAAG,WACjBD,EAAQG,MAAM,CAAGE,CACnB,GAEIL,CAEV,GAiDA,SAASM,EAAQC,CAAI,CAAEd,CAAO,EAC5B,MAAO,CACLe,SAlDkBD,CAAI,CAAEd,CAAO,EACjC,IAAMF,EAAQD,EAASG,GACjB,CAAC,CAACgB,EAAkBC,EAAkBC,EAAgB,CAAEC,EAAS,CAAGC,CAAAA,EAAAA,EAAAA,UAAAA,EACxE,IACE,IAAMC,EAAYvB,EAAMwB,GAAG,CAACR,UAC5B,OAAWS,EAAE,CAACC,CAAI,CAAC,EAAE,CAAEH,IAAcG,CAAI,CAAC,EAAE,GAAK1B,GAAS0B,CAAI,CAAC,EAAE,GAAKV,EAC7DU,EAEF,CAACH,EAAWvB,EAAOgB,EAAK,EAEjC,KAAK,EACL,IAAM,CAAChB,EAAMwB,GAAG,CAACR,GAAOhB,EAAOgB,EAAK,EAElCL,EAAQO,EACRC,CAAAA,IAAqBnB,GAASoB,IAAoBJ,CAAAA,IACpDK,IACAV,EAAQX,EAAMwB,GAAG,CAACR,IAEpB,IAAMW,EAAQzB,MAAAA,EAAkB,KAAK,EAAIA,EAAQyB,KAAK,CAatD,MAZAC,CAAAA,EAAAA,EAAAA,SAAAA,EAAU,KACR,IAAMC,EAAQ7B,EAAM8B,GAAG,CAACd,EAAM,KAC5B,GAAI,iBAAOW,EAAoB,CAC7BI,WAAWV,EAAUM,GACrB,MACF,CACAN,GACF,GAEA,OADAA,IACOQ,CACT,EAAG,CAAC7B,EAAOgB,EAAMW,EAAM,EACvBK,CAAAA,EAAAA,EAAAA,aAAAA,EAAcrB,GACPP,EAAcO,GAASJ,EAAII,GAASA,CAC7C,EAkBiBK,EAAMd,GAEnB+B,SAlBgBjB,CAAI,CAAEd,CAAO,EAC/B,IAAMF,EAAQD,EAASG,GAUvB,MATgBgC,CAAAA,EAAAA,EAAAA,WAAAA,EACd,sCAAIC,EAAAA,MAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,CAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CACF,GAA0E,CAAE,WAAWnB,CAAAA,EACrF,MAAM,MAAU,qBAElB,OAAOhB,EAAMoC,GAAG,CAACpB,KAASmB,EAC5B,EACA,CAACnC,EAAOgB,EAAK,CAGjB,EAMeA,EAAMd,GAClB,4BC2dCmC,2DAjkBJ,IAAIC,EAAW,EACf,SAAStB,EAAKuB,CAAI,CAAEC,CAAK,EACvB,IAAMC,EAAM,OAAkBC,MAAA,CAAX,EAAEJ,GACfK,EAAS,CACbC,SAAU,IAAMH,CAClB,EAWA,MAVI,mBAAOF,EACTI,EAAOJ,IAAI,CAAGA,GAEdI,EAAOE,IAAI,CAAGN,EACdI,EAAOJ,IAAI,CAAGO,EACdH,EAAOH,KAAK,CAAGO,GAEbP,GACFG,CAAAA,EAAOH,KAAK,CAAGA,CAAAA,EAEVG,CACT,CACA,SAASG,EAAYtB,CAAG,EACtB,OAAOA,EAAI,IAAI,CACjB,CACA,SAASuB,EAAavB,CAAG,CAAEY,CAAG,CAAEY,CAAG,EACjC,OAAOZ,EACL,IAAI,CACJ,mBAAOY,EAAqBA,EAAIxB,EAAI,IAAI,GAAKwB,EAEjD,CAEA,IAAMC,EAAa,CAACjC,EAAMkC,IAAMlC,EAAKmC,WAAW,CAAGnC,EAAKmC,WAAW,CAACD,GAAKA,IAAMlC,EACzEoC,EAAkB,GAAU,SAAUpC,EACtCqC,EAAyB,GAAU,CAAC,CAACrC,EAAKwB,KAAK,CAC/Cc,EAAmC,IAAIC,QACvCC,EAAwB,CAAC/C,EAASgD,KACtCH,EAAiBlB,GAAG,CAAC3B,EAASgD,GAC9BhD,EAAQiD,KAAK,CAAC,KACd,GAAGC,OAAO,CAAC,IAAML,EAAiBM,MAAM,CAACnD,GAC3C,EACMoD,EAAgB,CAACpD,EAASqD,KAC9B,IAAML,EAASH,EAAiB9B,GAAG,CAACf,GAChCgD,IACFH,EAAiBM,MAAM,CAACnD,GACxBgD,EAAOK,GAEX,EACMC,EAAiB,CAACtD,EAASE,KAC/BF,EAAQC,MAAM,CAAG,YACjBD,EAAQE,KAAK,CAAGA,CAClB,EACMqD,EAAgB,CAACvD,EAASK,KAC9BL,EAAQC,MAAM,CAAG,WACjBD,EAAQG,MAAM,CAAGE,CACnB,EACMV,EAAgB,GAAO,kBAAQC,CAAAA,MAAAA,EAAY,KAAK,EAAIA,EAAEC,IAAI,EAC1D2D,EAAmB,CAACf,EAAGgB,IAAM,CAAC,CAAChB,GAAK,MAAOA,GAAK,MAAOgB,GAAKC,OAAO1C,EAAE,CAACyB,EAAErC,CAAC,CAAEqD,EAAErD,CAAC,EAC9EuD,EAAmB,CAAClB,EAAGgB,IAAM,CAAC,CAAChB,GAAK,MAAOA,GAAK,MAAOgB,GAAKC,OAAO1C,EAAE,CAACyB,EAAEpC,CAAC,CAAEoD,EAAEpD,CAAC,EAC9EuD,EAAsB,GAAO,CAAC,CAACnB,GAAK,MAAOA,GAAKA,EAAErC,CAAC,YAAYyD,QAC/DC,EAA0B,CAACrB,EAAGgB,IAAM,MAAOhB,GAAK,MAAOgB,GAAKhB,EAAErC,CAAC,CAAC2D,IAAI,EAAItB,EAAErC,CAAC,CAAC2D,IAAI,GAAKN,EAAErD,CAAC,CAAC2D,IAAI,CAC7FC,EAAkB,IACtB,GAAI,MAAOC,EACT,MAAMA,EAAU5D,CAAC,CAEnB,OAAO4D,EAAU7D,CAAC,EAEd8D,EAAc,SAIdC,EACAC,EAJJ,IAAMC,EAA+B,IAAIvB,QACnCwB,EAA6B,IAAIxB,QACjCyB,EAA6B,IAAIC,IAIrCL,EAAqC,IAAIM,IACzCL,EAA+B,IAAIK,IAErC,IAAMC,EAAe,GAAUL,EAAatD,GAAG,CAACR,GAC1CoE,EAAe,CAACpE,EAAM0D,KAExBP,OAAOkB,MAAM,CAACX,GAEhB,IAAMY,EAAgBH,EAAanE,GAKnC,GAJA8D,EAAa1C,GAAG,CAACpB,EAAM0D,GAClBM,EAAWO,GAAG,CAACvE,IAClBgE,EAAW5C,GAAG,CAACpB,EAAMsE,GAEnBjB,EAAoBiB,GAAgB,CACtC,IAAMxB,EAAO,MAAOY,EAAYA,EAAU7D,CAAC,YAAYyD,QAAUI,EAAU7D,CAAC,CAAGyD,QAAQkB,OAAO,CAACd,EAAU7D,CAAC,EAAIyD,QAAQmB,MAAM,CAACf,EAAU5D,CAAC,CACpIwE,CAAAA,EAAczE,CAAC,GAAKiD,GACtBD,EAAcyB,EAAczE,CAAC,CAAEiD,EAEnC,CACF,EACM4B,EAAqB,CAAC1E,EAAM2E,EAAeC,EAAkBC,KACjE,IAAMC,EAAe,IAAIb,IACvBY,EAA2BF,EAAcI,CAAC,CAAG,MAE3CC,EAAU,GACdJ,EAAiBK,OAAO,CAAC,CAACC,EAAQhD,KAC5B,CAACgD,GAAUjD,EAAWjC,EAAMkC,IAC9BgD,CAAAA,EAASP,CAAAA,EAEPO,GACFJ,EAAa1D,GAAG,CAACc,EAAGgD,GAChBP,EAAcI,CAAC,CAACvE,GAAG,CAAC0B,KAAOgD,GAC7BF,CAAAA,EAAU,KAGZG,QAAQC,IAAI,CAAC,6BAEjB,GACIJ,CAAAA,GAAWL,EAAcI,CAAC,CAACM,IAAI,GAAKP,EAAaO,IAAI,GACvDV,CAAAA,EAAcI,CAAC,CAAGD,CAAAA,CAEtB,EACMQ,EAAe,CAACtF,EAAML,EAAOiF,EAAkBC,KACnD,IAAMP,EAAgBH,EAAanE,GAC7B2E,EAAgB,CACpBI,EAAG,CAACT,MAAAA,EAAwB,KAAK,EAAIA,EAAcS,CAAC,GAAqB,IAAId,IAC7EpE,EAAGF,CACL,EASA,GARIiF,GACFF,EACE1E,EACA2E,EACAC,EACAC,GAGA5B,EAAiBqB,EAAeK,IAAkBL,EAAcS,CAAC,GAAKJ,EAAcI,CAAC,CACvF,OAAOT,EAET,GAAIjB,EAAoBiB,IAAkBjB,EAAoBsB,IAAkBpB,EAAwBe,EAAeK,GAAgB,CACrI,GAAIL,EAAcS,CAAC,GAAKJ,EAAcI,CAAC,CACrC,OAAOT,CAEPK,CAAAA,EAAc9E,CAAC,CAAGyE,EAAczE,CAAC,CAIrC,OADAuE,EAAapE,EAAM2E,GACZA,CACT,EACMY,EAAwB,CAACvF,EAAMwF,EAAgBZ,EAAkBa,KACrE,GAAIrG,EAAcoG,GAAiB,KAC7BE,EACJ,IAAMC,EAA4B,KAChC,IAAMrB,EAAgBH,EAAanE,GACnC,GAAI,CAACqD,EAAoBiB,IAAkBA,EAAczE,CAAC,GAAKJ,EAC7D,OAEF,IAAMkF,EAAgBW,EACpBtF,EACAP,EACAmF,GAEEb,EAAWQ,GAAG,CAACvE,IAASsE,EAAcS,CAAC,GAAKJ,EAAcI,CAAC,EAC7Da,EAAkB5F,EAAM2E,EAAeL,EAAcS,CAAC,CAE1D,EACMtF,EAAU,IAAI6D,QAAQ,CAACkB,EAASC,KACpC,IAAIoB,EAAU,GACdL,EAAelG,IAAI,CACjB,IACOuG,IACHA,EAAU,GACV9C,EAAetD,EAASI,GACxB2E,EAAQ3E,GACR8F,IAEJ,EACA,IACOE,IACHA,EAAU,GACV7C,EAAcvD,EAASK,GACvB2E,EAAO3E,GACP6F,IAEJ,GAEFD,EAAkB,IACXG,IACHA,EAAU,GACV/C,EAAKxD,IAAI,CACP,GAAOyD,EAAetD,EAASI,GAC/B,GAAOmD,EAAcvD,EAASK,IAEhC0E,EAAQ1B,GAEZ,CACF,GASA,OARArD,EAAQ+D,IAAI,CAAGgC,EACf/F,EAAQC,MAAM,CAAG,UACjB8C,EAAsB/C,EAAS,IACzBqD,GACF4C,EAAgB5C,GAElB2C,MAAAA,GAAgCA,GAClC,GACOH,EAAatF,EAAMP,EAASmF,EAAkB,GACvD,CACA,OAAOU,EAAatF,EAAMwF,EAAgBZ,EAC5C,EACMkB,EAAe,CAAC9F,EAAM+F,EAAOnB,KACjC,IAAMN,EAAgBH,EAAanE,GAC7B2E,EAAgB,CACpBI,EAAG,CAACT,MAAAA,EAAwB,KAAK,EAAIA,EAAcS,CAAC,GAAqB,IAAId,IAC7EnE,EAAGiG,CACL,QAIA,CAHInB,GACFF,EAAmB1E,EAAM2E,EAAeC,GAEtCxB,EAAiBkB,EAAeK,IAAkBL,EAAcS,CAAC,GAAKJ,EAAcI,CAAC,EAChFT,GAETF,EAAapE,EAAM2E,GACZA,EACT,EACMqB,EAAgB,CAAChG,EAAMiG,SAmCvBC,EACAC,EAnCJ,IAAMzC,EAAYS,EAAanE,GAC/B,GAAI,CAACiG,GAASvC,IACRK,EAAWQ,GAAG,CAACvE,IAGfoG,MAAMC,IAAI,CAAC3C,EAAUqB,CAAC,EAAEuB,KAAK,CAAC,OAAC,CAACpE,EAAGqE,EAAE,CAAAC,EACvC,GAAItE,IAAMlC,EACR,MAAO,GAET,IAAMkF,EAASc,EAAc9D,GAC7B,OAAOgD,IAAWqB,GAAKtD,EAAiBiC,EAAQqB,EAClD,IARE,OAAO7C,EAYX,IAAMkB,EAAmC,IAAIX,IACzCwC,EAAS,GA4Cb,GAAI,CACF,IAAMjB,EAAiBxF,EAAKuB,IAAI,CA5CnB,IACb,GAAIU,EAAWjC,EAAMkC,GAAI,CACvB,IAAMwE,EAAUvC,EAAajC,GAC7B,GAAIwE,EAEF,OADA9B,EAAiBxD,GAAG,CAACc,EAAGwE,GACjBjD,EAAgBiD,GAEzB,GAAItE,EAAgBF,GAElB,OADA0C,EAAiBxD,GAAG,CAACc,EAAG,KAAK,GACtBA,EAAEL,IAAI,OAET,MAAU,eAClB,CACA,IAAMqD,EAASc,EAAc9D,GAE7B,OADA0C,EAAiBxD,GAAG,CAACc,EAAGgD,GACjBzB,EAAgByB,EACzB,EAGgB,CACd,IAAIyB,QAAS,CAIX,OAHKT,GACHA,CAAAA,EAAa,IAAIU,eAAAA,EAEZV,EAAWS,MAAM,EAE1B,IAAIR,SAAU,CAcZ,OAb2E9D,EAAuBrC,IAChGmF,QAAQC,IAAI,CAAC,uDAEX,CAACe,GAAW9D,EAAuBrC,IACrCmG,CAAAA,EAAU,sCAAIhF,EAAAA,MAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,CAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAIZ,GAH0EsF,GACxEtB,QAAQC,IAAI,CAAC,6CAEX,CAACqB,EACH,OAAOI,EAAU7G,KAASmB,EAE9B,GAEKgF,CACT,CACF,GAGE,OAAOZ,EACLvF,EACAwF,EACAZ,EACA,IAAMsB,MAAAA,EAAqB,KAAK,EAAIA,EAAWY,KAAK,GAExD,CAAE,MAAOf,EAAO,CACd,OAAOD,EAAa9F,EAAM+F,EAAOnB,EACnC,QAAU,CACR6B,EAAS,EACX,CACF,EAEMM,EAAU,IACd,IAAIC,EAAUjD,EAAWvD,GAAG,CAACR,GAI7B,OAHKgH,GACHA,CAAAA,EAAUC,EAAUjH,EAAAA,EAEfgH,CACT,EACME,EAAiB,CAAClH,EAAMgH,IAAY,CAACA,EAAQG,CAAC,CAAC9B,IAAI,EAAK,EAAC2B,EAAQI,CAAC,CAAC/B,IAAI,EAAI2B,IAAAA,EAAQI,CAAC,CAAC/B,IAAI,EAAU2B,EAAQI,CAAC,CAAC7C,GAAG,CAACvE,EAAAA,EACjHqH,EAAU,IACd,IAAML,EAAUjD,EAAWvD,GAAG,CAACR,GAC3BgH,GAAWE,EAAelH,EAAMgH,IAClCM,EAAYtH,EAEhB,EACMuH,EAAsB,IAC1B,IAAMC,EAAgB,IACpB,IAAIC,EACJ,IAAMC,EAAa,IAAIxD,IAAI,MAACuD,CAAAA,EAAK1D,EAAWvD,GAAG,CAAC0B,EAAAA,EAAc,KAAK,EAAIuF,EAAGL,CAAC,EAO3E,OANApD,EAAWiB,OAAO,CAAC,CAAC0C,EAAGC,KACrB,IAAIC,EACA,OAACA,CAAAA,EAAM1D,EAAayD,EAAAA,EAAwB,KAAK,EAAIC,EAAI9C,CAAC,CAACR,GAAG,CAACrC,EAAAA,GACjEwF,EAAWI,GAAG,CAACF,EAEnB,GACOF,CACT,EACMK,EAAiB,EAAI3B,CACrB4B,EAA8B,IAAI9D,IAClC+D,EAAQ,IACZ,IAAID,EAAYzD,GAAG,CAAC2D,IAIpB,IAAK,IAAMC,KADXH,EAAYF,GAAG,CAACI,GACAV,EAAcU,IACxBA,IAAMC,GACRF,EAAME,GAGVJ,EAAeK,IAAI,CAACF,GACtB,EACAD,EAAMjI,GACN,IAAMqI,EAA+B,IAAInE,IAAI,CAAClE,EAAK,EACnD,IAAK,IAAIsI,EAAIP,EAAeQ,MAAM,CAAG,EAAGD,GAAK,EAAG,EAAEA,EAAG,CACnD,IAAMpG,EAAI6F,CAAc,CAACO,EAAE,CACrBhE,EAAgBH,EAAajC,GACnC,GAAI,CAACoC,EACH,SAEF,IAAIkE,EAAiB,GACrB,IAAK,IAAMC,KAAOnE,EAAcS,CAAC,CAAC2D,IAAI,GACpC,GAAID,IAAQvG,GAAKmG,EAAa9D,GAAG,CAACkE,GAAM,CACtCD,EAAiB,GACjB,KACF,CAEEA,GAEE,CAACvF,EAAiBqB,EADA0B,EAAc9D,EAAG,MAErCmG,EAAaP,GAAG,CAAC5F,EAGvB,CACF,EACMyG,EAAiB,SAAC3I,CAAAA,6BAASmB,EAAAA,MAAAA,EAAAA,EAAAA,EAAAA,EAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAC/B,IAAIsF,EAAS,GA0BPmC,EAAS5I,EAAKwB,KAAK,CAzBV,GAAOiC,EAAgBuC,EAAc9D,IACrC,SAACA,CAAAA,MACV2G,6BADgBC,EAAAA,MAAAA,EAAAA,EAAAA,EAAAA,EAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAEpB,GAAI7G,EAAWjC,EAAMkC,GAAI,CACvB,GAAI,CAACE,EAAgBF,GACnB,MAAM,MAAU,qBAIbe,EAFiBkB,EAAajC,GACbqD,EAAsBrD,EAAG4G,CAAK,CAAC,EAAE,IAErDvB,EAAoBrF,EAExB,MACE2G,EAAIF,EAAezG,KAAM4G,GAE3B,GAAI,CAACrC,EAAQ,CACX,IAAMsC,EAAUC,IAEdpF,EAAmBqB,OAAO,CACxB,GAAOkC,EAAE,CAAE8B,KAAM,cAAeF,QAAAA,CAAQ,GAG9C,CACA,OAAOF,CACT,KAC6C1H,GAE7C,OADAsF,EAAS,GACFmC,CACT,EACM/B,EAAY,SAAC7G,CAAAA,6BAASmB,EAAAA,MAAAA,EAAAA,EAAAA,EAAAA,EAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAC1B,IAAMyH,EAASD,EAAe3I,KAASmB,GACjC4H,EAAUC,IAMhB,OAJEpF,EAAmBqB,OAAO,CACxB,GAAOkC,EAAE,CAAE8B,KAAM,QAASF,QAAAA,CAAQ,IAG/BH,CACT,EACM3B,EAAY,CAACjH,EAAMkJ,EAAkBC,KACzC,IAAI1B,EACJ,IAAM2B,EAAQD,GAAgB,EAAE,OAC/B1B,CAAAA,EAAKtD,EAAanE,EAAAA,GAA0ByH,EAAG1C,CAAC,CAACE,OAAO,CAAC,CAAC0C,EAAGzF,KAC5D,IAAMmH,EAAWtF,EAAWvD,GAAG,CAAC0B,GAC5BmH,EACFA,EAASjC,CAAC,CAACU,GAAG,CAAC9H,GAEXkC,IAAMlC,GACRiH,EAAU/E,EAAGlC,EAAMoJ,EAGzB,GACApD,EAAchG,GACd,IAAMgH,EAAU,CACdI,EAAG,IAAIlD,IAAIgF,GAAoB,CAACA,EAAiB,EACjD/B,EAAmB,IAAIjD,GACzB,EAKA,GAJAH,EAAW3C,GAAG,CAACpB,EAAMgH,GAEnBnD,EAAaiE,GAAG,CAAC9H,GAEfqC,EAAuBrC,IAASA,EAAKsJ,OAAO,CAAE,CAChD,GAAM,CAAEA,QAAAA,CAAO,CAAE,CAAGtJ,EACpBoJ,EAAMhB,IAAI,CAAC,KACT,IAAMmB,EAAYD,EAAQ,sCAAInI,EAAAA,MAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,CAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,QAAS0F,EAAU7G,KAASmB,KACtDoI,GACFvC,CAAAA,EAAQwC,CAAC,CAAGD,CAAAA,CAEhB,EACF,CAIA,OAHKJ,GACHC,EAAMnE,OAAO,CAAC,GAAOwE,KAEhBzC,CACT,EACMM,EAAc,IAClB,IAAIG,EACJ,IAAM8B,EAAY,MAAC9B,CAAAA,EAAK1D,EAAWvD,GAAG,CAACR,EAAAA,EAAiB,KAAK,EAAIyH,EAAG+B,CAAC,CACjED,GACFA,IAEFxF,EAAWnB,MAAM,CAAC5C,GAEhB6D,EAAajB,MAAM,CAAC5C,GAEtB,IAAM0D,EAAYS,EAAanE,GAC3B0D,GACEL,EAAoBK,IACtBb,EAAca,EAAU7D,CAAC,EAE3B6D,EAAUqB,CAAC,CAACE,OAAO,CAAC,CAAC0C,EAAGzF,KACtB,GAAIA,IAAMlC,EAAM,CACd,IAAMgH,EAAUjD,EAAWvD,GAAG,CAAC0B,GAC3B8E,IACFA,EAAQI,CAAC,CAACxE,MAAM,CAAC5C,GACbkH,EAAehF,EAAG8E,IACpBM,EAAYpF,GAGlB,CACF,IAEAiD,QAAQC,IAAI,CAAC,6CAA8CpF,EAE/D,EACM4F,EAAoB,CAAC5F,EAAM0D,EAAWgG,KAC1C,IAAMC,EAAS,IAAIzF,IAAIR,EAAUqB,CAAC,CAAC2D,IAAI,IACjCkB,EAAsC,IAAI1F,GAChDwF,OAAAA,GAAoCA,EAAiBzE,OAAO,CAAC,CAAC0C,EAAGzF,KAC/D,GAAIyH,EAAOpF,GAAG,CAACrC,GAAI,CACjByH,EAAO/G,MAAM,CAACV,GACd,MACF,CACA0H,EAAoB9B,GAAG,CAAC5F,GACxB,IAAM8E,EAAUjD,EAAWvD,GAAG,CAAC0B,GAC3B8E,GACFA,EAAQI,CAAC,CAACxE,MAAM,CAAC5C,EAErB,GACA2J,EAAO1E,OAAO,CAAC,IACb,IAAM+B,EAAUjD,EAAWvD,GAAG,CAAC0B,GAC3B8E,EACFA,EAAQI,CAAC,CAACU,GAAG,CAAC9H,GACL+D,EAAWQ,GAAG,CAACvE,IACxBiH,EAAU/E,EAAGlC,EAEjB,GACA4J,EAAoB3E,OAAO,CAAC,IAC1B,IAAM+B,EAAUjD,EAAWvD,GAAG,CAAC0B,GAC3B8E,GAAWE,EAAehF,EAAG8E,IAC/BM,EAAYpF,EAEhB,EACF,EACM8G,EAAe,KACnB,IAAID,EAIJ,IAFEA,EAA0B,IAAI7E,IAEzBF,EAAWqB,IAAI,EAAE,CACtB,IAAMwE,EAAUzD,MAAMC,IAAI,CAACrC,GAC3BA,EAAW8F,KAAK,GAChBD,EAAQ5E,OAAO,CAAC,OAAC,CAACjF,EAAMsE,EAAc,CAAAkC,EAC9B9C,EAAYS,EAAanE,GAC/B,GAAI0D,EAAW,CACb,IAAMsD,EAAUjD,EAAWvD,GAAG,CAACR,GAC3BgH,GAAWtD,EAAUqB,CAAC,GAAMT,CAAAA,MAAAA,EAAwB,KAAK,EAAIA,EAAcS,CAAC,GAC9Ea,EAAkB5F,EAAM0D,EAAWY,MAAAA,EAAwB,KAAK,EAAIA,EAAcS,CAAC,EAEjFiC,GAAW,CAEd,EAAC3D,EAAoBiB,IAAmBrB,CAAAA,EAAiBqB,EAAeZ,IAAcN,EAAiBkB,EAAeZ,EAAAA,CAAS,IAC9HsD,EAAQG,CAAC,CAAClC,OAAO,CAAC,GAAc8E,KAE9BhB,EAAQjB,GAAG,CAAC9H,GAGlB,MACEmF,QAAQC,IAAI,CAAC,+BAEjB,EACF,CAEE,OAAO2D,CAEX,EAoBE,MAAO,CACLvI,IA5Pa,GAAUiD,EAAgBuC,EAAchG,IA6PrDoB,IAAKyF,EACL/F,IAtBkB,CAACd,EAAM+J,KAC3B,IAAM/C,EAAUD,EAAQ/G,GAClB+I,EAAUC,IACVgB,EAAYhD,EAAQG,CAAC,QAC3B6C,EAAUlC,GAAG,CAACiC,GAEZnG,EAAmBqB,OAAO,CACxB,GAAOkC,EAAE,CAAE8B,KAAM,MAAOF,QAAAA,CAAQ,IAG7B,KACLiB,EAAUpH,MAAM,CAACmH,GACjB1C,EAAQrH,GAEN4D,EAAmBqB,OAAO,CAAC,GAAOkC,EAAE,CAAE8B,KAAM,OAAQ,GAExD,CACF,EAOIgB,oBAAqB,CAAC9C,EAAG+C,KACvB,GAAIA,IAAAA,EACF,MAAM,MAAU,4CAGlB,OADAtG,EAAmBkE,GAAG,CAACX,GAChB,KACLvD,EAAmBhB,MAAM,CAACuE,EAC5B,CACF,EACAgD,sBAAuB,IAAMtG,EAAauG,MAAM,GAChDC,mBAAoB,GAAOvG,EAAatD,GAAG,CAAC0B,GAC5CoI,gBAAiB,GAAOvG,EAAWvD,GAAG,CAAC0B,GACvCqI,kBAAmB,IACjB,IAAK,GAAM,CAACvK,EAAMwF,EAAe,GAAI4E,EAC/BhI,EAAgBpC,KAClBuF,EAAsBvF,EAAMwF,GAC5B+B,EAAoBvH,IAGxB,IAAM+I,EAAUC,IAChBpF,EAAmBqB,OAAO,CACxB,GAAOkC,EAAE,CAAE8B,KAAM,UAAWF,QAAAA,CAAQ,GAExC,CACF,CAOJ,CAGM,CAAoD,UAApD,OAAOyB,WAAWC,6BAA6B,CACjD,EAAED,WAAWC,6BAA6B,CAE1CD,WAAWC,6BAA6B,CAAG,EAG/C,IAAMtL,EAAkB,KACjBkC,IACoH,IAA7CmJ,WAAWC,6BAA6B,EAChHtF,QAAQC,IAAI,CACV,gJAGJ/D,EAAesC,KAEVtC","sources":["webpack://_N_E/./node_modules/@ant-design/icons-svg/es/asn/ArrowRightOutlined.js","webpack://_N_E/./node_modules/@ant-design/icons/es/icons/ArrowRightOutlined.js","webpack://_N_E/./node_modules/@ant-design/icons-svg/es/asn/SettingOutlined.js","webpack://_N_E/./node_modules/@ant-design/icons/es/icons/SettingOutlined.js","webpack://_N_E/./node_modules/jotai/esm/react.mjs","webpack://_N_E/./node_modules/jotai/esm/vanilla.mjs","webpack://_N_E/<anon>"],"sourcesContent":["// This icon file is generated automatically.\nvar ArrowRightOutlined = { \"icon\": { \"tag\": \"svg\", \"attrs\": { \"viewBox\": \"64 64 896 896\", \"focusable\": \"false\" }, \"children\": [{ \"tag\": \"path\", \"attrs\": { \"d\": \"M869 487.8L491.2 159.9c-2.9-2.5-6.6-3.9-10.5-3.9h-88.5c-7.4 0-10.8 9.2-5.2 14l350.2 304H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h585.1L386.9 854c-5.6 4.9-2.2 14 5.2 14h91.5c1.9 0 3.8-.7 5.2-2L869 536.2a32.07 32.07 0 000-48.4z\" } }] }, \"name\": \"arrow-right\", \"theme\": \"outlined\" };\nexport default ArrowRightOutlined;\n","import _extends from \"@babel/runtime/helpers/esm/extends\";\n// GENERATE BY ./scripts/generate.ts\n// DON NOT EDIT IT MANUALLY\n\nimport * as React from 'react';\nimport ArrowRightOutlinedSvg from \"@ant-design/icons-svg/es/asn/ArrowRightOutlined\";\nimport AntdIcon from \"../components/AntdIcon\";\nvar ArrowRightOutlined = function ArrowRightOutlined(props, ref) {\n  return /*#__PURE__*/React.createElement(AntdIcon, _extends({}, props, {\n    ref: ref,\n    icon: ArrowRightOutlinedSvg\n  }));\n};\nif (process.env.NODE_ENV !== 'production') {\n  ArrowRightOutlined.displayName = 'ArrowRightOutlined';\n}\nexport default /*#__PURE__*/React.forwardRef(ArrowRightOutlined);","// This icon file is generated automatically.\nvar SettingOutlined = { \"icon\": { \"tag\": \"svg\", \"attrs\": { \"viewBox\": \"64 64 896 896\", \"focusable\": \"false\" }, \"children\": [{ \"tag\": \"path\", \"attrs\": { \"d\": \"M924.8 625.7l-65.5-56c3.1-19 4.7-38.4 4.7-57.8s-1.6-38.8-4.7-57.8l65.5-56a32.03 32.03 0 009.3-35.2l-.9-2.6a443.74 443.74 0 00-79.7-137.9l-1.8-2.1a32.12 32.12 0 00-35.1-9.5l-81.3 28.9c-30-24.6-63.5-44-99.7-57.6l-15.7-85a32.05 32.05 0 00-25.8-25.7l-2.7-.5c-52.1-9.4-106.9-9.4-159 0l-2.7.5a32.05 32.05 0 00-25.8 25.7l-15.8 85.4a351.86 351.86 0 00-99 57.4l-81.9-29.1a32 32 0 00-35.1 9.5l-1.8 2.1a446.02 446.02 0 00-79.7 137.9l-.9 2.6c-4.5 12.5-.8 26.5 9.3 35.2l66.3 56.6c-3.1 18.8-4.6 38-4.6 57.1 0 19.2 1.5 38.4 4.6 57.1L99 625.5a32.03 32.03 0 00-9.3 35.2l.9 2.6c18.1 50.4 44.9 96.9 79.7 137.9l1.8 2.1a32.12 32.12 0 0035.1 9.5l81.9-29.1c29.8 24.5 63.1 43.9 99 57.4l15.8 85.4a32.05 32.05 0 0025.8 25.7l2.7.5a449.4 449.4 0 00159 0l2.7-.5a32.05 32.05 0 0025.8-25.7l15.7-85a350 350 0 0099.7-57.6l81.3 28.9a32 32 0 0035.1-9.5l1.8-2.1c34.8-41.1 61.6-87.5 79.7-137.9l.9-2.6c4.5-12.3.8-26.3-9.3-35zM788.3 465.9c2.5 15.1 3.8 30.6 3.8 46.1s-1.3 31-3.8 46.1l-6.6 40.1 74.7 63.9a370.03 370.03 0 01-42.6 73.6L721 702.8l-31.4 25.8c-23.9 19.6-50.5 35-79.3 45.8l-38.1 14.3-17.9 97a377.5 377.5 0 01-85 0l-17.9-97.2-37.8-14.5c-28.5-10.8-55-26.2-78.7-45.7l-31.4-25.9-93.4 33.2c-17-22.9-31.2-47.6-42.6-73.6l75.5-64.5-6.5-40c-2.4-14.9-3.7-30.3-3.7-45.5 0-15.3 1.2-30.6 3.7-45.5l6.5-40-75.5-64.5c11.3-26.1 25.6-50.7 42.6-73.6l93.4 33.2 31.4-25.9c23.7-19.5 50.2-34.9 78.7-45.7l37.9-14.3 17.9-97.2c28.1-3.2 56.8-3.2 85 0l17.9 97 38.1 14.3c28.7 10.8 55.4 26.2 79.3 45.8l31.4 25.8 92.8-32.9c17 22.9 31.2 47.6 42.6 73.6L781.8 426l6.5 39.9zM512 326c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm79.2 255.2A111.6 111.6 0 01512 614c-29.9 0-58-11.7-79.2-32.8A111.6 111.6 0 01400 502c0-29.9 11.7-58 32.8-79.2C454 401.6 482.1 390 512 390c29.9 0 58 11.6 79.2 32.8A111.6 111.6 0 01624 502c0 29.9-11.7 58-32.8 79.2z\" } }] }, \"name\": \"setting\", \"theme\": \"outlined\" };\nexport default SettingOutlined;\n","import _extends from \"@babel/runtime/helpers/esm/extends\";\n// GENERATE BY ./scripts/generate.ts\n// DON NOT EDIT IT MANUALLY\n\nimport * as React from 'react';\nimport SettingOutlinedSvg from \"@ant-design/icons-svg/es/asn/SettingOutlined\";\nimport AntdIcon from \"../components/AntdIcon\";\nvar SettingOutlined = function SettingOutlined(props, ref) {\n  return /*#__PURE__*/React.createElement(AntdIcon, _extends({}, props, {\n    ref: ref,\n    icon: SettingOutlinedSvg\n  }));\n};\nif (process.env.NODE_ENV !== 'production') {\n  SettingOutlined.displayName = 'SettingOutlined';\n}\nexport default /*#__PURE__*/React.forwardRef(SettingOutlined);","'use client';\nimport ReactExports, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\n\nconst StoreContext = createContext(void 0);\nconst useStore = (options) => {\n  const store = useContext(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n};\nconst Provider = ({\n  children,\n  store\n}) => {\n  const storeRef = useRef();\n  if (!store && !storeRef.current) {\n    storeRef.current = createStore();\n  }\n  return createElement(\n    StoreContext.Provider,\n    {\n      value: store || storeRef.current\n    },\n    children\n  );\n};\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst use = ReactExports.use || ((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    promise.status = \"pending\";\n    promise.then(\n      (v) => {\n        promise.status = \"fulfilled\";\n        promise.value = v;\n      },\n      (e) => {\n        promise.status = \"rejected\";\n        promise.reason = e;\n      }\n    );\n    throw promise;\n  }\n});\nfunction useAtomValue(atom, options) {\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\n    (prev) => {\n      const nextValue = store.get(atom);\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n        return prev;\n      }\n      return [nextValue, store, atom];\n    },\n    void 0,\n    () => [store.get(atom), store, atom]\n  );\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    rerender();\n    value = store.get(atom);\n  }\n  const delay = options == null ? void 0 : options.delay;\n  useEffect(() => {\n    const unsub = store.sub(atom, () => {\n      if (typeof delay === \"number\") {\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom, delay]);\n  useDebugValue(value);\n  return isPromiseLike(value) ? use(value) : value;\n}\n\nfunction useSetAtom(atom, options) {\n  const store = useStore(options);\n  const setAtom = useCallback(\n    (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      return store.set(atom, ...args);\n    },\n    [store, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, options) {\n  return [\n    useAtomValue(atom, options),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, options)\n  ];\n}\n\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\n","let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(\n    this,\n    typeof arg === \"function\" ? arg(get(this)) : arg\n  );\n}\n\nconst isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {\n  }).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst isEqualAtomValue = (a, b) => !!a && \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => !!a && \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a) => !!a && \"v\" in a && a.v instanceof Promise;\nconst isEqualPromiseAtomValue = (a, b) => \"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let storeListenersRev2;\n  let mountedAtoms;\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    storeListenersRev2 = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => atomStateMap.get(atom);\n  const setAtomState = (atom, atomState) => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = getAtomState(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      if (prevAtomState.v !== next) {\n        cancelPromise(prevAtomState.v, next);\n      }\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, nextDependencies, keepPreviousDependencies) => {\n    const dependencies = new Map(\n      keepPreviousDependencies ? nextAtomState.d : null\n    );\n    let changed = false;\n    nextDependencies.forEach((aState, a) => {\n      if (!aState && isSelfAtom(atom, a)) {\n        aState = nextAtomState;\n      }\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, nextDependencies, keepPreviousDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      v: value\n    };\n    if (nextDependencies) {\n      updateDependencies(\n        atom,\n        nextAtomState,\n        nextDependencies,\n        keepPreviousDependencies\n      );\n    }\n    if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n      if (prevAtomState.d === nextAtomState.d) {\n        return prevAtomState;\n      } else {\n        nextAtomState.v = prevAtomState.v;\n      }\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise) => {\n    if (isPromiseLike(valueOrPromise)) {\n      let continuePromise;\n      const updatePromiseDependencies = () => {\n        const prevAtomState = getAtomState(atom);\n        if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\n          return;\n        }\n        const nextAtomState = setAtomValue(\n          atom,\n          promise,\n          nextDependencies\n        );\n        if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {\n          mountDependencies(atom, nextAtomState, prevAtomState.d);\n        }\n      };\n      const promise = new Promise((resolve, reject) => {\n        let settled = false;\n        valueOrPromise.then(\n          (v) => {\n            if (!settled) {\n              settled = true;\n              resolvePromise(promise, v);\n              resolve(v);\n              updatePromiseDependencies();\n            }\n          },\n          (e) => {\n            if (!settled) {\n              settled = true;\n              rejectPromise(promise, e);\n              reject(e);\n              updatePromiseDependencies();\n            }\n          }\n        );\n        continuePromise = (next) => {\n          if (!settled) {\n            settled = true;\n            next.then(\n              (v) => resolvePromise(promise, v),\n              (e) => rejectPromise(promise, e)\n            );\n            resolve(next);\n          }\n        };\n      });\n      promise.orig = valueOrPromise;\n      promise.status = \"pending\";\n      registerCancelPromise(promise, (next) => {\n        if (next) {\n          continuePromise(next);\n        }\n        abortPromise == null ? void 0 : abortPromise();\n      });\n      return setAtomValue(atom, promise, nextDependencies, true);\n    }\n    return setAtomValue(atom, valueOrPromise, nextDependencies);\n  };\n  const setAtomError = (atom, error, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      e: error\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom, force) => {\n    const atomState = getAtomState(atom);\n    if (!force && atomState) {\n      if (mountedMap.has(atom)) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(([a, s]) => {\n        if (a === atom) {\n          return true;\n        }\n        const aState = readAtomState(a);\n        return aState === s || isEqualAtomValue(aState, s);\n      })) {\n        return atomState;\n      }\n    }\n    const nextDependencies = /* @__PURE__ */ new Map();\n    let isSync = true;\n    const getter = (a) => {\n      if (isSelfAtom(atom, a)) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          nextDependencies.set(a, aState2);\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          nextDependencies.set(a, void 0);\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      nextDependencies.set(a, aState);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom.read(getter, options);\n      return setAtomValueOrPromise(\n        atom,\n        valueOrPromise,\n        nextDependencies,\n        () => controller == null ? void 0 : controller.abort()\n      );\n    } catch (error) {\n      return setAtomError(atom, error, nextDependencies);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\n  const addAtom = (atom) => {\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (atom) => {\n    const mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  const recomputeDependents = (atom) => {\n    const getDependents = (a) => {\n      var _a;\n      const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);\n      pendingMap.forEach((_, pendingAtom) => {\n        var _a2;\n        if ((_a2 = getAtomState(pendingAtom)) == null ? void 0 : _a2.d.has(a)) {\n          dependents.add(pendingAtom);\n        }\n      });\n      return dependents;\n    };\n    const topsortedAtoms = new Array();\n    const markedAtoms = /* @__PURE__ */ new Set();\n    const visit = (n) => {\n      if (markedAtoms.has(n)) {\n        return;\n      }\n      markedAtoms.add(n);\n      for (const m of getDependents(n)) {\n        if (n !== m) {\n          visit(m);\n        }\n      }\n      topsortedAtoms.push(n);\n    };\n    visit(atom);\n    const changedAtoms = /* @__PURE__ */ new Set([atom]);\n    for (let i = topsortedAtoms.length - 1; i >= 0; --i) {\n      const a = topsortedAtoms[i];\n      const prevAtomState = getAtomState(a);\n      if (!prevAtomState) {\n        continue;\n      }\n      let hasChangedDeps = false;\n      for (const dep of prevAtomState.d.keys()) {\n        if (dep !== a && changedAtoms.has(dep)) {\n          hasChangedDeps = true;\n          break;\n        }\n      }\n      if (hasChangedDeps) {\n        const nextAtomState = readAtomState(a, true);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          changedAtoms.add(a);\n        }\n      }\n    }\n  };\n  const writeAtomState = (atom, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (isSelfAtom(atom, a)) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        const flushed = flushPending();\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          storeListenersRev2.forEach(\n            (l) => l({ type: \"async-write\", flushed })\n          );\n        }\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const result = writeAtomState(atom, ...args);\n    const flushed = flushPending();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(\n        (l) => l({ type: \"write\", flushed })\n      );\n    }\n    return result;\n  };\n  const mountAtom = (atom, initialDependent, onMountQueue) => {\n    var _a;\n    const queue = onMountQueue || [];\n    (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom, queue);\n        }\n      }\n    });\n    readAtomState(atom);\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const { onMount } = atom;\n      queue.push(() => {\n        const onUnmount = onMount((...args) => writeAtom(atom, ...args));\n        if (onUnmount) {\n          mounted.u = onUnmount;\n        }\n      });\n    }\n    if (!onMountQueue) {\n      queue.forEach((f) => f());\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    const maybeUnmountAtomSet = /* @__PURE__ */ new Set();\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      maybeUnmountAtomSet.add(a);\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n      }\n    });\n    depSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n    maybeUnmountAtomSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted && canUnmountAtom(a, mounted)) {\n        unmountAtom(a);\n      }\n    });\n  };\n  const flushPending = () => {\n    let flushed;\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      flushed = /* @__PURE__ */ new Set();\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(atom);\n        if (atomState) {\n          const mounted = mountedMap.get(atom);\n          if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          if (mounted && !// TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach((listener) => listener());\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n              flushed.add(atom);\n            }\n          }\n        } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      return flushed;\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = addAtom(atom);\n    const flushed = flushPending();\n    const listeners = mounted.l;\n    listeners.add(listener);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(\n        (l) => l({ type: \"sub\", flushed })\n      );\n    }\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        storeListenersRev2.forEach((l) => l({ type: \"unsub\" }));\n      }\n    };\n  };\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change without notice)\n      dev_subscribe_store: (l, rev) => {\n        if (rev !== 2) {\n          throw new Error(\"The current StoreListener revision is 2.\");\n        }\n        storeListenersRev2.add(l);\n        return () => {\n          storeListenersRev2.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: (a) => atomStateMap.get(a),\n      dev_get_mounted: (a) => mountedMap.get(a),\n      dev_restore_atoms: (values) => {\n        for (const [atom, valueOrPromise] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValueOrPromise(atom, valueOrPromise);\n            recomputeDependents(atom);\n          }\n        }\n        const flushed = flushPending();\n        storeListenersRev2.forEach(\n          (l) => l({ type: \"restore\", flushed })\n        );\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nif ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n  if (typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__ === \"number\") {\n    ++globalThis.__NUMBER_OF_JOTAI_INSTANCES__;\n  } else {\n    globalThis.__NUMBER_OF_JOTAI_INSTANCES__ = 1;\n  }\n}\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && globalThis.__NUMBER_OF_JOTAI_INSTANCES__ !== 1) {\n      console.warn(\n        \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n      );\n    }\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\n\nexport { atom, createStore, getDefaultStore };\n"],"names":["asn_ArrowRightOutlined","icons_ArrowRightOutlined","React","props","ref","AntdIcon","_extends","icon","ArrowRightOutlinedSvg","asn_SettingOutlined","icons_SettingOutlined","SettingOutlinedSvg","StoreContext","createContext","useStore","store","useContext","options","getDefaultStore","isPromiseLike","x","then","use","ReactExports","promise","status","value","reason","v","e","useAtom","atom","useAtomValue","valueFromReducer","storeFromReducer","atomFromReducer","rerender","useReducer","nextValue","get","is","prev","delay","useEffect","unsub","sub","setTimeout","useDebugValue","useSetAtom","useCallback","args","set","defaultStore","keyCount","read","write","key","concat","config","toString","init","defaultRead","defaultWrite","arg","isSelfAtom","a","unstable_is","hasInitialValue","isActuallyWritableAtom","cancelPromiseMap","WeakMap","registerCancelPromise","cancel","catch","finally","delete","cancelPromise","next","resolvePromise","rejectPromise","isEqualAtomValue","b","Object","isEqualAtomError","hasPromiseAtomValue","Promise","isEqualPromiseAtomValue","orig","returnAtomValue","atomState","createStore","storeListenersRev2","mountedAtoms","atomStateMap","mountedMap","pendingMap","Map","Set","getAtomState","setAtomState","freeze","prevAtomState","has","resolve","reject","updateDependencies","nextAtomState","nextDependencies","keepPreviousDependencies","dependencies","d","changed","forEach","aState","console","warn","size","setAtomValue","setAtomValueOrPromise","valueOrPromise","abortPromise","continuePromise","updatePromiseDependencies","mountDependencies","settled","setAtomError","error","readAtomState","force","controller","setSelf","Array","from","every","s","param","isSync","aState2","signal","AbortController","writeAtom","abort","addAtom","mounted","mountAtom","canUnmountAtom","l","t","delAtom","unmountAtom","recomputeDependents","getDependents","_a","dependents","_","pendingAtom","_a2","add","topsortedAtoms","markedAtoms","visit","n","m","push","changedAtoms","i","length","hasChangedDeps","dep","keys","writeAtomState","result","r","args2","flushed","flushPending","type","initialDependent","onMountQueue","queue","aMounted","onMount","onUnmount","u","f","prevDependencies","depSet","maybeUnmountAtomSet","pending","clear","listener","listeners","dev_subscribe_store","rev","dev_get_mounted_atoms","values","dev_get_atom_state","dev_get_mounted","dev_restore_atoms","globalThis","__NUMBER_OF_JOTAI_INSTANCES__"],"sourceRoot":""}